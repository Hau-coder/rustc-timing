commit 7a526ca05a6a1223429ee4f3de6260f0e5a2b24a
Merge: d274e55 36a926a
Author: bors <bors@rust-lang.org>
Date:   Sun Jan 15 11:03:48 2017 +0000

    Auto merge of #39052 - alexcrichton:fix-rebuild, r=brson
    
    rustbuild: Skip the build_helper crate in tests
    
    I've been noticing some spurious recompiles of the final stage on Travis lately
    and in debugging them I found a case where we were a little to eager to update
    a stamp file due to the build_helper library being introduced during the testing
    phase.
    
    Part of the rustbuild system detects when libstd is recompiled and automatically
    cleans out future directories to ensure that dirtyness propagation works. To do
    this rustbuild doesn't know the artifact name of the standard library so it just
    probes everything in the target directory, looking to see if anything changed.
    
    The problem here happened where:
    
    * First, rustbuild would compile everything (a normal build)
    * Next, rustbuild would run all tests
    * During testing, the libbuild_helper library was introduced into the target
      directory, making it look like a change happened because a file is newer
      than the newest was before
    * Detecting a change, the next compilation would then cause rustbuild to clean
      out old artifacts and recompile everything again.
    
    This commit fixes this problem by correcting rustbuild to just not test the
    build_helper crate at all. This crate doesn't have any unit tests, nor is it
    intended to. That way the target directories should stay the same throughout
    testing after a previous build.
rustc 1.15.0-nightly (daf8c1dfc 2016-12-05)
-rwxr-xr-x 1 root root 9432 Dec  6 15:39 /usr/local/bin/rustc
rustc: ./regex-0.1.80@050-expand
git apply 050-expand.diff
find . -name "*.rs" | xargs touch
git diff
diff --git a/regex-0.1.80/src/compile.rs b/regex-0.1.80/src/compile.rs
index 9db743f..9a32d30 100644
--- a/regex-0.1.80/src/compile.rs
+++ b/regex-0.1.80/src/compile.rs
@@ -137,6 +137,8 @@ impl Compiler {
     }
 
     fn compile_one(mut self, expr: &Expr) -> result::Result<Program, Error> {
+        {} // @030
+
         // If we're compiling a forward DFA and we aren't anchored, then
         // add a `.*?` before the first capture group.
         // Other matching engines handle this by baking the logic into the
diff --git a/regex-0.1.80/src/expand.rs b/regex-0.1.80/src/expand.rs
index 9bea703..b4ae1ab 100644
--- a/regex-0.1.80/src/expand.rs
+++ b/regex-0.1.80/src/expand.rs
@@ -5,6 +5,7 @@ use memchr::memchr;
 use bytes::Captures;
 
 pub fn expand(caps: &Captures, mut replacement: &[u8], dst: &mut Vec<u8>) {
+    { }
     while !replacement.is_empty() {
         match memchr(b'$', replacement) {
             None => break,
@@ -84,6 +85,7 @@ fn find_cap_ref(mut replacement: &[u8]) -> Option<CaptureRef> {
 }
 
 fn is_valid_cap_letter(b: &u8) -> bool {
+    { }
     match *b {
         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,
         _ => false,
RUSTFLAGS="-Z incremental=incr" cargo rustc  -- \
  -Ztime-passes -Zinput-stats -Z incremental-info
makefile:34: recipe for target 'all@050-expand' failed
done
