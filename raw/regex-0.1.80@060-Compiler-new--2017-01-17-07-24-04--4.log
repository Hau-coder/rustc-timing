commit a167c042abed695a049abf3919ce929765e6cc30
Merge: 0825c96 66ef5f2
Author: bors <bors@rust-lang.org>
Date:   Tue Jan 17 12:31:15 2017 +0000

    Auto merge of #39110 - petrochenkov:sum, r=eddyb
    
    Merge ObjectSum and PolyTraitRef in AST/HIR + some other refactoring
    
    `ObjectSum` and `PolyTraitRef` are the same thing (list of bounds), they exist separately only due to parser quirks. The second commit merges them.
    
    The first commit replaces `Path` with `Ty` in (not yet supported) equality predicates. They are parsed as types anyway and arbitrary types can always be disguised as paths using aliases, so this doesn't add any new functionality.
    
    The third commit uses `Vec` instead of `P<[T]>` in AST. AST is not immutable like HIR and `Vec`s are more convenient for it, unnecessary conversions are also avoided.
    
    The last commit renames `parse_ty_sum` (which is used for parsing types in general) into `parse_ty`, and renames `parse_ty` (which is used restricted contexts where `+` is not permitted due to operator priorities or other reasons) into `parse_ty_no_plus`.
    
    This is the first part of https://github.com/rust-lang/rust/issues/39085#issuecomment-272743755 and https://github.com/rust-lang/rust/issues/39080 focused on data changes and mechanical renaming, I'll submit a PR with parser changes a bit later.
    
    r? @eddyb
rustc 1.15.0-nightly (daf8c1dfc 2016-12-05)
-rwxr-xr-x 1 root root 9432 Dec  6 15:39 /usr/local/bin/rustc
rustc: ./regex-0.1.80@060-Compiler-new
git apply 060-Compiler-new.diff
find . -name "*.rs" | xargs touch
git diff
diff --git a/regex-0.1.80/src/compile.rs b/regex-0.1.80/src/compile.rs
index 9db743f..629328a 100644
--- a/regex-0.1.80/src/compile.rs
+++ b/regex-0.1.80/src/compile.rs
@@ -54,6 +54,7 @@ impl Compiler {
     ///
     /// Various options can be set before calling `compile` on an expression.
     pub fn new() -> Self {
+        {}
         Compiler {
             insts: vec![],
             compiled: Program::new(),
@@ -137,6 +138,8 @@ impl Compiler {
     }
 
     fn compile_one(mut self, expr: &Expr) -> result::Result<Program, Error> {
+        {} // @030
+
         // If we're compiling a forward DFA and we aren't anchored, then
         // add a `.*?` before the first capture group.
         // Other matching engines handle this by baking the logic into the
diff --git a/regex-0.1.80/src/expand.rs b/regex-0.1.80/src/expand.rs
index 9bea703..b4ae1ab 100644
--- a/regex-0.1.80/src/expand.rs
+++ b/regex-0.1.80/src/expand.rs
@@ -5,6 +5,7 @@ use memchr::memchr;
 use bytes::Captures;
 
 pub fn expand(caps: &Captures, mut replacement: &[u8], dst: &mut Vec<u8>) {
+    { }
     while !replacement.is_empty() {
         match memchr(b'$', replacement) {
             None => break,
@@ -84,6 +85,7 @@ fn find_cap_ref(mut replacement: &[u8]) -> Option<CaptureRef> {
 }
 
 fn is_valid_cap_letter(b: &u8) -> bool {
+    { }
     match *b {
         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,
         _ => false,
RUSTFLAGS="-Z incremental=incr" cargo rustc  -- \
  -Ztime-passes -Zinput-stats -Z incremental-info
makefile:42: recipe for target 'all@060-Compiler-new' failed
done
