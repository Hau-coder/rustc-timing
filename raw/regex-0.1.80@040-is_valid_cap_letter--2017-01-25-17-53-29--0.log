commit df8debf6d9afc431adbbd8311dcaf2b70eb9762e
Merge: 94d4589 f9bdf34
Author: bors <bors@rust-lang.org>
Date:   Wed Jan 25 23:08:56 2017 +0000

    Auto merge of #38920 - petrochenkov:selfimpl, r=eddyb
    
    Partially implement RFC 1647 (`Self` in impl headers)
    
    The name resolution part is easy, but the typeck part contains an unexpected problem.
    
    It turns out that `Self` type *depends* on bounds and `where` clauses, so we need to convert them first to determine what the `Self` type is! If bounds/`where` clauses can refer to `Self` then we have a cyclic dependency.
    This is required to support impls like this:
    ```
    // Found in libcollections
    impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> { .... }
                                                          ^^^^^ associated type `Item` is found using information from bounds
    
    ```
    I'm not yet sure how to resolve this issue.
    One possible solution (that feels hacky) is to make two passes over generics - first collect predicates ignoring everything involving `Self`, then determine `Self`, then collect predicates again without ignoring anything. (Some kind of lazy on-demand checking or something looks like a proper solution.)
    
    This patch in its current state doesn't solve the problem with `Self` in bounds, so the only observable things it does is improving error messages and supporting `impl Trait<Self> for Type {}`.
    
    There's also a question about feature gating. It's non-trivial to *detect* "newly resolved" `Self`s to feature gate them, but it's simple to *enable* the new resolution behavior when the feature gate is already specified. Alternatively this can be considered a bug fix and merged without a feature gate.
    
    cc https://github.com/rust-lang/rust/issues/38864
    r? @nikomatsakis
    cc @eddyb
    Whitespace ignoring diff https://github.com/rust-lang/rust/pull/38920/files?w=1
rustc 1.15.0-nightly (daf8c1dfc 2016-12-05)
-rwxr-xr-x 1 root root 9432 Dec  6 15:39 /usr/local/bin/rustc
rustc: ./regex-0.1.80@040-is_valid_cap_letter
git apply 040-is_valid_cap_letter.diff
find . -name "*.rs" | xargs touch
git diff
diff --git a/regex-0.1.80/src/compile.rs b/regex-0.1.80/src/compile.rs
index 9db743f..9a32d30 100644
--- a/regex-0.1.80/src/compile.rs
+++ b/regex-0.1.80/src/compile.rs
@@ -137,6 +137,8 @@ impl Compiler {
     }
 
     fn compile_one(mut self, expr: &Expr) -> result::Result<Program, Error> {
+        {} // @030
+
         // If we're compiling a forward DFA and we aren't anchored, then
         // add a `.*?` before the first capture group.
         // Other matching engines handle this by baking the logic into the
diff --git a/regex-0.1.80/src/expand.rs b/regex-0.1.80/src/expand.rs
index 9bea703..3b6ae94 100644
--- a/regex-0.1.80/src/expand.rs
+++ b/regex-0.1.80/src/expand.rs
@@ -84,6 +84,7 @@ fn find_cap_ref(mut replacement: &[u8]) -> Option<CaptureRef> {
 }
 
 fn is_valid_cap_letter(b: &u8) -> bool {
+    { }
     match *b {
         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,
         _ => false,
RUSTFLAGS="-Z incremental=incr" cargo rustc  -- \
  -Ztime-passes -Zinput-stats -Z incremental-info
makefile:26: recipe for target 'all@040-is_valid_cap_letter' failed
done
