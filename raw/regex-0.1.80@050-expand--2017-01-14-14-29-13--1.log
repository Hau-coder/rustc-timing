commit 93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6
Merge: 2f9dedb e97f104
Author: bors <bors@rust-lang.org>
Date:   Sat Jan 14 19:47:23 2017 +0000

    Auto merge of #38992 - nagisa:i128-minvallit, r=eddyb
    
    Fix two const-eval issues related to i128 negation
    
    First issue here was the fact that weâ€™d only allow negating integers in i64 range in case the
    integer was not infered yes. While this is not the direct cause of the issue, its still good to fix
    it.
    
    The real issue here is the code handling specifically the `min_value` literals. While I128_OVERFLOW
    has the expected value (0x8000_..._0000), match using this value as a pattern is handled
    incorrectly by the stage1 compiler (it seems to be handled correctly, by the stage2 compiler). So
    what we do here is extract this pattern into an explicit `==` until the next snapshot.
    
    Fixes #38987
rustc 1.15.0-nightly (daf8c1dfc 2016-12-05)
-rwxr-xr-x 1 root root 9432 Dec  6 15:39 /usr/local/bin/rustc
rustc: ./regex-0.1.80@050-expand
git apply 050-expand.diff
find . -name "*.rs" | xargs touch
git diff
diff --git a/regex-0.1.80/src/compile.rs b/regex-0.1.80/src/compile.rs
index 9db743f..9a32d30 100644
--- a/regex-0.1.80/src/compile.rs
+++ b/regex-0.1.80/src/compile.rs
@@ -137,6 +137,8 @@ impl Compiler {
     }
 
     fn compile_one(mut self, expr: &Expr) -> result::Result<Program, Error> {
+        {} // @030
+
         // If we're compiling a forward DFA and we aren't anchored, then
         // add a `.*?` before the first capture group.
         // Other matching engines handle this by baking the logic into the
diff --git a/regex-0.1.80/src/expand.rs b/regex-0.1.80/src/expand.rs
index 9bea703..b4ae1ab 100644
--- a/regex-0.1.80/src/expand.rs
+++ b/regex-0.1.80/src/expand.rs
@@ -5,6 +5,7 @@ use memchr::memchr;
 use bytes::Captures;
 
 pub fn expand(caps: &Captures, mut replacement: &[u8], dst: &mut Vec<u8>) {
+    { }
     while !replacement.is_empty() {
         match memchr(b'$', replacement) {
             None => break,
@@ -84,6 +85,7 @@ fn find_cap_ref(mut replacement: &[u8]) -> Option<CaptureRef> {
 }
 
 fn is_valid_cap_letter(b: &u8) -> bool {
+    { }
     match *b {
         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,
         _ => false,
RUSTFLAGS="-Z incremental=incr" cargo rustc  -- \
  -Ztime-passes -Zinput-stats -Z incremental-info
makefile:34: recipe for target 'all@050-expand' failed
done
